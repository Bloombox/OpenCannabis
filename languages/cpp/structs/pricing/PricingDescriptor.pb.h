// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: structs/pricing/PricingDescriptor.proto

#ifndef PROTOBUF_structs_2fpricing_2fPricingDescriptor_2eproto__INCLUDED
#define PROTOBUF_structs_2fpricing_2fPricingDescriptor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "structs/pricing/SaleDescriptor.pb.h"
// @@protoc_insertion_point(includes)
class FreebiePricingDescriptor;
class FreebiePricingDescriptorDefaultTypeInternal;
extern FreebiePricingDescriptorDefaultTypeInternal _FreebiePricingDescriptor_default_instance_;
class PricingDescriptor;
class PricingDescriptorDefaultTypeInternal;
extern PricingDescriptorDefaultTypeInternal _PricingDescriptor_default_instance_;
class PricingTierAvailability;
class PricingTierAvailabilityDefaultTypeInternal;
extern PricingTierAvailabilityDefaultTypeInternal _PricingTierAvailability_default_instance_;
class ProductPricing;
class ProductPricingDefaultTypeInternal;
extern ProductPricingDefaultTypeInternal _ProductPricing_default_instance_;
class SaleDescriptor;
class SaleDescriptorDefaultTypeInternal;
extern SaleDescriptorDefaultTypeInternal _SaleDescriptor_default_instance_;
class UnitPricingDescriptor;
class UnitPricingDescriptorDefaultTypeInternal;
extern UnitPricingDescriptorDefaultTypeInternal _UnitPricingDescriptor_default_instance_;
class WeightedPricingDescriptor;
class WeightedPricingDescriptorDefaultTypeInternal;
extern WeightedPricingDescriptorDefaultTypeInternal _WeightedPricingDescriptor_default_instance_;

namespace protobuf_structs_2fpricing_2fPricingDescriptor_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_structs_2fpricing_2fPricingDescriptor_2eproto

enum PricingType {
  UNIT = 0,
  WEIGHTED = 1,
  FREEBIE = 2,
  PricingType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PricingType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PricingType_IsValid(int value);
const PricingType PricingType_MIN = UNIT;
const PricingType PricingType_MAX = FREEBIE;
const int PricingType_ARRAYSIZE = PricingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PricingType_descriptor();
inline const ::std::string& PricingType_Name(PricingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PricingType_descriptor(), value);
}
inline bool PricingType_Parse(
    const ::std::string& name, PricingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PricingType>(
    PricingType_descriptor(), name, value);
}
enum PricingWeightTier {
  OTHER = 0,
  GRAM = 1,
  HALFGRAM = 2,
  QUARTERGRAM = 3,
  DUB = 4,
  EIGHTH = 5,
  QUARTER = 6,
  HALF = 7,
  OUNCE = 8,
  POUND = 9,
  PricingWeightTier_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PricingWeightTier_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PricingWeightTier_IsValid(int value);
const PricingWeightTier PricingWeightTier_MIN = OTHER;
const PricingWeightTier PricingWeightTier_MAX = POUND;
const int PricingWeightTier_ARRAYSIZE = PricingWeightTier_MAX + 1;

const ::google::protobuf::EnumDescriptor* PricingWeightTier_descriptor();
inline const ::std::string& PricingWeightTier_Name(PricingWeightTier value) {
  return ::google::protobuf::internal::NameOfEnum(
    PricingWeightTier_descriptor(), value);
}
inline bool PricingWeightTier_Parse(
    const ::std::string& name, PricingWeightTier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PricingWeightTier>(
    PricingWeightTier_descriptor(), name, value);
}
// ===================================================================

class PricingTierAvailability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PricingTierAvailability) */ {
 public:
  PricingTierAvailability();
  virtual ~PricingTierAvailability();

  PricingTierAvailability(const PricingTierAvailability& from);

  inline PricingTierAvailability& operator=(const PricingTierAvailability& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PricingTierAvailability& default_instance();

  static inline const PricingTierAvailability* internal_default_instance() {
    return reinterpret_cast<const PricingTierAvailability*>(
               &_PricingTierAvailability_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(PricingTierAvailability* other);
  void Swap(PricingTierAvailability* other);

  // implements Message ----------------------------------------------

  inline PricingTierAvailability* New() const PROTOBUF_FINAL { return New(NULL); }

  PricingTierAvailability* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PricingTierAvailability& from);
  void MergeFrom(const PricingTierAvailability& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PricingTierAvailability* other);
  protected:
  explicit PricingTierAvailability(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool offered = 1;
  void clear_offered();
  static const int kOfferedFieldNumber = 1;
  bool offered() const;
  void set_offered(bool value);

  // bool available = 2;
  void clear_available();
  static const int kAvailableFieldNumber = 2;
  bool available() const;
  void set_available(bool value);

  // @@protoc_insertion_point(class_scope:PricingTierAvailability)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool offered_;
  bool available_;
  mutable int _cached_size_;
  friend struct protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitPricingDescriptor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UnitPricingDescriptor) */ {
 public:
  UnitPricingDescriptor();
  virtual ~UnitPricingDescriptor();

  UnitPricingDescriptor(const UnitPricingDescriptor& from);

  inline UnitPricingDescriptor& operator=(const UnitPricingDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitPricingDescriptor& default_instance();

  static inline const UnitPricingDescriptor* internal_default_instance() {
    return reinterpret_cast<const UnitPricingDescriptor*>(
               &_UnitPricingDescriptor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(UnitPricingDescriptor* other);
  void Swap(UnitPricingDescriptor* other);

  // implements Message ----------------------------------------------

  inline UnitPricingDescriptor* New() const PROTOBUF_FINAL { return New(NULL); }

  UnitPricingDescriptor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnitPricingDescriptor& from);
  void MergeFrom(const UnitPricingDescriptor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnitPricingDescriptor* other);
  protected:
  explicit UnitPricingDescriptor(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SaleDescriptor discounts = 3;
  int discounts_size() const;
  void clear_discounts();
  static const int kDiscountsFieldNumber = 3;
  const ::SaleDescriptor& discounts(int index) const;
  ::SaleDescriptor* mutable_discounts(int index);
  ::SaleDescriptor* add_discounts();
  ::google::protobuf::RepeatedPtrField< ::SaleDescriptor >*
      mutable_discounts();
  const ::google::protobuf::RepeatedPtrField< ::SaleDescriptor >&
      discounts() const;

  // .PricingTierAvailability status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  private:
  void _slow_mutable_status();
  void _slow_set_allocated_status(
      ::google::protobuf::Arena* message_arena, ::PricingTierAvailability** status);
  ::PricingTierAvailability* _slow_release_status();
  public:
  const ::PricingTierAvailability& status() const;
  ::PricingTierAvailability* mutable_status();
  ::PricingTierAvailability* release_status();
  void set_allocated_status(::PricingTierAvailability* status);
  ::PricingTierAvailability* unsafe_arena_release_status();
  void unsafe_arena_set_allocated_status(
      ::PricingTierAvailability* status);

  // float price_value = 1;
  void clear_price_value();
  static const int kPriceValueFieldNumber = 1;
  float price_value() const;
  void set_price_value(float value);

  // @@protoc_insertion_point(class_scope:UnitPricingDescriptor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::SaleDescriptor > discounts_;
  ::PricingTierAvailability* status_;
  float price_value_;
  mutable int _cached_size_;
  friend struct protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WeightedPricingDescriptor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WeightedPricingDescriptor) */ {
 public:
  WeightedPricingDescriptor();
  virtual ~WeightedPricingDescriptor();

  WeightedPricingDescriptor(const WeightedPricingDescriptor& from);

  inline WeightedPricingDescriptor& operator=(const WeightedPricingDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const WeightedPricingDescriptor& default_instance();

  static inline const WeightedPricingDescriptor* internal_default_instance() {
    return reinterpret_cast<const WeightedPricingDescriptor*>(
               &_WeightedPricingDescriptor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(WeightedPricingDescriptor* other);
  void Swap(WeightedPricingDescriptor* other);

  // implements Message ----------------------------------------------

  inline WeightedPricingDescriptor* New() const PROTOBUF_FINAL { return New(NULL); }

  WeightedPricingDescriptor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WeightedPricingDescriptor& from);
  void MergeFrom(const WeightedPricingDescriptor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WeightedPricingDescriptor* other);
  protected:
  explicit WeightedPricingDescriptor(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .UnitPricingDescriptor tier = 2;
  bool has_tier() const;
  void clear_tier();
  static const int kTierFieldNumber = 2;
  private:
  void _slow_mutable_tier();
  void _slow_set_allocated_tier(
      ::google::protobuf::Arena* message_arena, ::UnitPricingDescriptor** tier);
  ::UnitPricingDescriptor* _slow_release_tier();
  public:
  const ::UnitPricingDescriptor& tier() const;
  ::UnitPricingDescriptor* mutable_tier();
  ::UnitPricingDescriptor* release_tier();
  void set_allocated_tier(::UnitPricingDescriptor* tier);
  ::UnitPricingDescriptor* unsafe_arena_release_tier();
  void unsafe_arena_set_allocated_tier(
      ::UnitPricingDescriptor* tier);

  // .PricingWeightTier weight = 1;
  void clear_weight();
  static const int kWeightFieldNumber = 1;
  ::PricingWeightTier weight() const;
  void set_weight(::PricingWeightTier value);

  // float weightInGrams = 3;
  void clear_weightingrams();
  static const int kWeightInGramsFieldNumber = 3;
  float weightingrams() const;
  void set_weightingrams(float value);

  // @@protoc_insertion_point(class_scope:WeightedPricingDescriptor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::UnitPricingDescriptor* tier_;
  int weight_;
  float weightingrams_;
  mutable int _cached_size_;
  friend struct protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FreebiePricingDescriptor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FreebiePricingDescriptor) */ {
 public:
  FreebiePricingDescriptor();
  virtual ~FreebiePricingDescriptor();

  FreebiePricingDescriptor(const FreebiePricingDescriptor& from);

  inline FreebiePricingDescriptor& operator=(const FreebiePricingDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FreebiePricingDescriptor& default_instance();

  static inline const FreebiePricingDescriptor* internal_default_instance() {
    return reinterpret_cast<const FreebiePricingDescriptor*>(
               &_FreebiePricingDescriptor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(FreebiePricingDescriptor* other);
  void Swap(FreebiePricingDescriptor* other);

  // implements Message ----------------------------------------------

  inline FreebiePricingDescriptor* New() const PROTOBUF_FINAL { return New(NULL); }

  FreebiePricingDescriptor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FreebiePricingDescriptor& from);
  void MergeFrom(const FreebiePricingDescriptor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FreebiePricingDescriptor* other);
  protected:
  explicit FreebiePricingDescriptor(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:FreebiePricingDescriptor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable int _cached_size_;
  friend struct protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PricingDescriptor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PricingDescriptor) */ {
 public:
  PricingDescriptor();
  virtual ~PricingDescriptor();

  PricingDescriptor(const PricingDescriptor& from);

  inline PricingDescriptor& operator=(const PricingDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PricingDescriptor& default_instance();

  static inline const PricingDescriptor* internal_default_instance() {
    return reinterpret_cast<const PricingDescriptor*>(
               &_PricingDescriptor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(PricingDescriptor* other);
  void Swap(PricingDescriptor* other);

  // implements Message ----------------------------------------------

  inline PricingDescriptor* New() const PROTOBUF_FINAL { return New(NULL); }

  PricingDescriptor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PricingDescriptor& from);
  void MergeFrom(const PricingDescriptor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PricingDescriptor* other);
  protected:
  explicit PricingDescriptor(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .UnitPricingDescriptor unit = 20;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 20;
  private:
  void _slow_mutable_unit();
  void _slow_set_allocated_unit(
      ::google::protobuf::Arena* message_arena, ::UnitPricingDescriptor** unit);
  ::UnitPricingDescriptor* _slow_release_unit();
  public:
  const ::UnitPricingDescriptor& unit() const;
  ::UnitPricingDescriptor* mutable_unit();
  ::UnitPricingDescriptor* release_unit();
  void set_allocated_unit(::UnitPricingDescriptor* unit);
  ::UnitPricingDescriptor* unsafe_arena_release_unit();
  void unsafe_arena_set_allocated_unit(
      ::UnitPricingDescriptor* unit);

  // .WeightedPricingDescriptor weighted = 21;
  bool has_weighted() const;
  void clear_weighted();
  static const int kWeightedFieldNumber = 21;
  private:
  void _slow_mutable_weighted();
  void _slow_set_allocated_weighted(
      ::google::protobuf::Arena* message_arena, ::WeightedPricingDescriptor** weighted);
  ::WeightedPricingDescriptor* _slow_release_weighted();
  public:
  const ::WeightedPricingDescriptor& weighted() const;
  ::WeightedPricingDescriptor* mutable_weighted();
  ::WeightedPricingDescriptor* release_weighted();
  void set_allocated_weighted(::WeightedPricingDescriptor* weighted);
  ::WeightedPricingDescriptor* unsafe_arena_release_weighted();
  void unsafe_arena_set_allocated_weighted(
      ::WeightedPricingDescriptor* weighted);

  // .FreebiePricingDescriptor freebie = 22;
  bool has_freebie() const;
  void clear_freebie();
  static const int kFreebieFieldNumber = 22;
  private:
  void _slow_mutable_freebie();
  void _slow_set_allocated_freebie(
      ::google::protobuf::Arena* message_arena, ::FreebiePricingDescriptor** freebie);
  ::FreebiePricingDescriptor* _slow_release_freebie();
  public:
  const ::FreebiePricingDescriptor& freebie() const;
  ::FreebiePricingDescriptor* mutable_freebie();
  ::FreebiePricingDescriptor* release_freebie();
  void set_allocated_freebie(::FreebiePricingDescriptor* freebie);
  ::FreebiePricingDescriptor* unsafe_arena_release_freebie();
  void unsafe_arena_set_allocated_freebie(
      ::FreebiePricingDescriptor* freebie);

  // .PricingType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::PricingType type() const;
  void set_type(::PricingType value);

  // @@protoc_insertion_point(class_scope:PricingDescriptor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::UnitPricingDescriptor* unit_;
  ::WeightedPricingDescriptor* weighted_;
  ::FreebiePricingDescriptor* freebie_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProductPricing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProductPricing) */ {
 public:
  ProductPricing();
  virtual ~ProductPricing();

  ProductPricing(const ProductPricing& from);

  inline ProductPricing& operator=(const ProductPricing& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductPricing& default_instance();

  static inline const ProductPricing* internal_default_instance() {
    return reinterpret_cast<const ProductPricing*>(
               &_ProductPricing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(ProductPricing* other);
  void Swap(ProductPricing* other);

  // implements Message ----------------------------------------------

  inline ProductPricing* New() const PROTOBUF_FINAL { return New(NULL); }

  ProductPricing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProductPricing& from);
  void MergeFrom(const ProductPricing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProductPricing* other);
  protected:
  explicit ProductPricing(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SaleDescriptor discounts = 1;
  int discounts_size() const;
  void clear_discounts();
  static const int kDiscountsFieldNumber = 1;
  const ::SaleDescriptor& discounts(int index) const;
  ::SaleDescriptor* mutable_discounts(int index);
  ::SaleDescriptor* add_discounts();
  ::google::protobuf::RepeatedPtrField< ::SaleDescriptor >*
      mutable_discounts();
  const ::google::protobuf::RepeatedPtrField< ::SaleDescriptor >&
      discounts() const;

  // repeated .PricingDescriptor manifest = 2;
  int manifest_size() const;
  void clear_manifest();
  static const int kManifestFieldNumber = 2;
  const ::PricingDescriptor& manifest(int index) const;
  ::PricingDescriptor* mutable_manifest(int index);
  ::PricingDescriptor* add_manifest();
  ::google::protobuf::RepeatedPtrField< ::PricingDescriptor >*
      mutable_manifest();
  const ::google::protobuf::RepeatedPtrField< ::PricingDescriptor >&
      manifest() const;

  // @@protoc_insertion_point(class_scope:ProductPricing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::SaleDescriptor > discounts_;
  ::google::protobuf::RepeatedPtrField< ::PricingDescriptor > manifest_;
  mutable int _cached_size_;
  friend struct protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PricingTierAvailability

// bool offered = 1;
inline void PricingTierAvailability::clear_offered() {
  offered_ = false;
}
inline bool PricingTierAvailability::offered() const {
  // @@protoc_insertion_point(field_get:PricingTierAvailability.offered)
  return offered_;
}
inline void PricingTierAvailability::set_offered(bool value) {
  
  offered_ = value;
  // @@protoc_insertion_point(field_set:PricingTierAvailability.offered)
}

// bool available = 2;
inline void PricingTierAvailability::clear_available() {
  available_ = false;
}
inline bool PricingTierAvailability::available() const {
  // @@protoc_insertion_point(field_get:PricingTierAvailability.available)
  return available_;
}
inline void PricingTierAvailability::set_available(bool value) {
  
  available_ = value;
  // @@protoc_insertion_point(field_set:PricingTierAvailability.available)
}

// -------------------------------------------------------------------

// UnitPricingDescriptor

// float price_value = 1;
inline void UnitPricingDescriptor::clear_price_value() {
  price_value_ = 0;
}
inline float UnitPricingDescriptor::price_value() const {
  // @@protoc_insertion_point(field_get:UnitPricingDescriptor.price_value)
  return price_value_;
}
inline void UnitPricingDescriptor::set_price_value(float value) {
  
  price_value_ = value;
  // @@protoc_insertion_point(field_set:UnitPricingDescriptor.price_value)
}

// .PricingTierAvailability status = 2;
inline bool UnitPricingDescriptor::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void UnitPricingDescriptor::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) delete status_;
  status_ = NULL;
}
inline const ::PricingTierAvailability& UnitPricingDescriptor::status() const {
  // @@protoc_insertion_point(field_get:UnitPricingDescriptor.status)
  return status_ != NULL ? *status_
                         : *::PricingTierAvailability::internal_default_instance();
}
inline ::PricingTierAvailability* UnitPricingDescriptor::mutable_status() {
  
  if (status_ == NULL) {
    _slow_mutable_status();
  }
  // @@protoc_insertion_point(field_mutable:UnitPricingDescriptor.status)
  return status_;
}
inline ::PricingTierAvailability* UnitPricingDescriptor::release_status() {
  // @@protoc_insertion_point(field_release:UnitPricingDescriptor.status)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_status();
  } else {
    ::PricingTierAvailability* temp = status_;
    status_ = NULL;
    return temp;
  }
}
inline  void UnitPricingDescriptor::set_allocated_status(::PricingTierAvailability* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status != NULL) {
    _slow_set_allocated_status(message_arena, &status);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:UnitPricingDescriptor.status)
}

// repeated .SaleDescriptor discounts = 3;
inline int UnitPricingDescriptor::discounts_size() const {
  return discounts_.size();
}
inline void UnitPricingDescriptor::clear_discounts() {
  discounts_.Clear();
}
inline const ::SaleDescriptor& UnitPricingDescriptor::discounts(int index) const {
  // @@protoc_insertion_point(field_get:UnitPricingDescriptor.discounts)
  return discounts_.Get(index);
}
inline ::SaleDescriptor* UnitPricingDescriptor::mutable_discounts(int index) {
  // @@protoc_insertion_point(field_mutable:UnitPricingDescriptor.discounts)
  return discounts_.Mutable(index);
}
inline ::SaleDescriptor* UnitPricingDescriptor::add_discounts() {
  // @@protoc_insertion_point(field_add:UnitPricingDescriptor.discounts)
  return discounts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SaleDescriptor >*
UnitPricingDescriptor::mutable_discounts() {
  // @@protoc_insertion_point(field_mutable_list:UnitPricingDescriptor.discounts)
  return &discounts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SaleDescriptor >&
UnitPricingDescriptor::discounts() const {
  // @@protoc_insertion_point(field_list:UnitPricingDescriptor.discounts)
  return discounts_;
}

// -------------------------------------------------------------------

// WeightedPricingDescriptor

// .PricingWeightTier weight = 1;
inline void WeightedPricingDescriptor::clear_weight() {
  weight_ = 0;
}
inline ::PricingWeightTier WeightedPricingDescriptor::weight() const {
  // @@protoc_insertion_point(field_get:WeightedPricingDescriptor.weight)
  return static_cast< ::PricingWeightTier >(weight_);
}
inline void WeightedPricingDescriptor::set_weight(::PricingWeightTier value) {
  
  weight_ = value;
  // @@protoc_insertion_point(field_set:WeightedPricingDescriptor.weight)
}

// .UnitPricingDescriptor tier = 2;
inline bool WeightedPricingDescriptor::has_tier() const {
  return this != internal_default_instance() && tier_ != NULL;
}
inline void WeightedPricingDescriptor::clear_tier() {
  if (GetArenaNoVirtual() == NULL && tier_ != NULL) delete tier_;
  tier_ = NULL;
}
inline const ::UnitPricingDescriptor& WeightedPricingDescriptor::tier() const {
  // @@protoc_insertion_point(field_get:WeightedPricingDescriptor.tier)
  return tier_ != NULL ? *tier_
                         : *::UnitPricingDescriptor::internal_default_instance();
}
inline ::UnitPricingDescriptor* WeightedPricingDescriptor::mutable_tier() {
  
  if (tier_ == NULL) {
    _slow_mutable_tier();
  }
  // @@protoc_insertion_point(field_mutable:WeightedPricingDescriptor.tier)
  return tier_;
}
inline ::UnitPricingDescriptor* WeightedPricingDescriptor::release_tier() {
  // @@protoc_insertion_point(field_release:WeightedPricingDescriptor.tier)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_tier();
  } else {
    ::UnitPricingDescriptor* temp = tier_;
    tier_ = NULL;
    return temp;
  }
}
inline  void WeightedPricingDescriptor::set_allocated_tier(::UnitPricingDescriptor* tier) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tier_;
  }
  if (tier != NULL) {
    _slow_set_allocated_tier(message_arena, &tier);
  }
  tier_ = tier;
  if (tier) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:WeightedPricingDescriptor.tier)
}

// float weightInGrams = 3;
inline void WeightedPricingDescriptor::clear_weightingrams() {
  weightingrams_ = 0;
}
inline float WeightedPricingDescriptor::weightingrams() const {
  // @@protoc_insertion_point(field_get:WeightedPricingDescriptor.weightInGrams)
  return weightingrams_;
}
inline void WeightedPricingDescriptor::set_weightingrams(float value) {
  
  weightingrams_ = value;
  // @@protoc_insertion_point(field_set:WeightedPricingDescriptor.weightInGrams)
}

// -------------------------------------------------------------------

// FreebiePricingDescriptor

// -------------------------------------------------------------------

// PricingDescriptor

// .PricingType type = 1;
inline void PricingDescriptor::clear_type() {
  type_ = 0;
}
inline ::PricingType PricingDescriptor::type() const {
  // @@protoc_insertion_point(field_get:PricingDescriptor.type)
  return static_cast< ::PricingType >(type_);
}
inline void PricingDescriptor::set_type(::PricingType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:PricingDescriptor.type)
}

// .UnitPricingDescriptor unit = 20;
inline bool PricingDescriptor::has_unit() const {
  return this != internal_default_instance() && unit_ != NULL;
}
inline void PricingDescriptor::clear_unit() {
  if (GetArenaNoVirtual() == NULL && unit_ != NULL) delete unit_;
  unit_ = NULL;
}
inline const ::UnitPricingDescriptor& PricingDescriptor::unit() const {
  // @@protoc_insertion_point(field_get:PricingDescriptor.unit)
  return unit_ != NULL ? *unit_
                         : *::UnitPricingDescriptor::internal_default_instance();
}
inline ::UnitPricingDescriptor* PricingDescriptor::mutable_unit() {
  
  if (unit_ == NULL) {
    _slow_mutable_unit();
  }
  // @@protoc_insertion_point(field_mutable:PricingDescriptor.unit)
  return unit_;
}
inline ::UnitPricingDescriptor* PricingDescriptor::release_unit() {
  // @@protoc_insertion_point(field_release:PricingDescriptor.unit)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_unit();
  } else {
    ::UnitPricingDescriptor* temp = unit_;
    unit_ = NULL;
    return temp;
  }
}
inline  void PricingDescriptor::set_allocated_unit(::UnitPricingDescriptor* unit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete unit_;
  }
  if (unit != NULL) {
    _slow_set_allocated_unit(message_arena, &unit);
  }
  unit_ = unit;
  if (unit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PricingDescriptor.unit)
}

// .WeightedPricingDescriptor weighted = 21;
inline bool PricingDescriptor::has_weighted() const {
  return this != internal_default_instance() && weighted_ != NULL;
}
inline void PricingDescriptor::clear_weighted() {
  if (GetArenaNoVirtual() == NULL && weighted_ != NULL) delete weighted_;
  weighted_ = NULL;
}
inline const ::WeightedPricingDescriptor& PricingDescriptor::weighted() const {
  // @@protoc_insertion_point(field_get:PricingDescriptor.weighted)
  return weighted_ != NULL ? *weighted_
                         : *::WeightedPricingDescriptor::internal_default_instance();
}
inline ::WeightedPricingDescriptor* PricingDescriptor::mutable_weighted() {
  
  if (weighted_ == NULL) {
    _slow_mutable_weighted();
  }
  // @@protoc_insertion_point(field_mutable:PricingDescriptor.weighted)
  return weighted_;
}
inline ::WeightedPricingDescriptor* PricingDescriptor::release_weighted() {
  // @@protoc_insertion_point(field_release:PricingDescriptor.weighted)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_weighted();
  } else {
    ::WeightedPricingDescriptor* temp = weighted_;
    weighted_ = NULL;
    return temp;
  }
}
inline  void PricingDescriptor::set_allocated_weighted(::WeightedPricingDescriptor* weighted) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete weighted_;
  }
  if (weighted != NULL) {
    _slow_set_allocated_weighted(message_arena, &weighted);
  }
  weighted_ = weighted;
  if (weighted) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PricingDescriptor.weighted)
}

// .FreebiePricingDescriptor freebie = 22;
inline bool PricingDescriptor::has_freebie() const {
  return this != internal_default_instance() && freebie_ != NULL;
}
inline void PricingDescriptor::clear_freebie() {
  if (GetArenaNoVirtual() == NULL && freebie_ != NULL) delete freebie_;
  freebie_ = NULL;
}
inline const ::FreebiePricingDescriptor& PricingDescriptor::freebie() const {
  // @@protoc_insertion_point(field_get:PricingDescriptor.freebie)
  return freebie_ != NULL ? *freebie_
                         : *::FreebiePricingDescriptor::internal_default_instance();
}
inline ::FreebiePricingDescriptor* PricingDescriptor::mutable_freebie() {
  
  if (freebie_ == NULL) {
    _slow_mutable_freebie();
  }
  // @@protoc_insertion_point(field_mutable:PricingDescriptor.freebie)
  return freebie_;
}
inline ::FreebiePricingDescriptor* PricingDescriptor::release_freebie() {
  // @@protoc_insertion_point(field_release:PricingDescriptor.freebie)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_freebie();
  } else {
    ::FreebiePricingDescriptor* temp = freebie_;
    freebie_ = NULL;
    return temp;
  }
}
inline  void PricingDescriptor::set_allocated_freebie(::FreebiePricingDescriptor* freebie) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete freebie_;
  }
  if (freebie != NULL) {
    _slow_set_allocated_freebie(message_arena, &freebie);
  }
  freebie_ = freebie;
  if (freebie) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PricingDescriptor.freebie)
}

// -------------------------------------------------------------------

// ProductPricing

// repeated .SaleDescriptor discounts = 1;
inline int ProductPricing::discounts_size() const {
  return discounts_.size();
}
inline void ProductPricing::clear_discounts() {
  discounts_.Clear();
}
inline const ::SaleDescriptor& ProductPricing::discounts(int index) const {
  // @@protoc_insertion_point(field_get:ProductPricing.discounts)
  return discounts_.Get(index);
}
inline ::SaleDescriptor* ProductPricing::mutable_discounts(int index) {
  // @@protoc_insertion_point(field_mutable:ProductPricing.discounts)
  return discounts_.Mutable(index);
}
inline ::SaleDescriptor* ProductPricing::add_discounts() {
  // @@protoc_insertion_point(field_add:ProductPricing.discounts)
  return discounts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SaleDescriptor >*
ProductPricing::mutable_discounts() {
  // @@protoc_insertion_point(field_mutable_list:ProductPricing.discounts)
  return &discounts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SaleDescriptor >&
ProductPricing::discounts() const {
  // @@protoc_insertion_point(field_list:ProductPricing.discounts)
  return discounts_;
}

// repeated .PricingDescriptor manifest = 2;
inline int ProductPricing::manifest_size() const {
  return manifest_.size();
}
inline void ProductPricing::clear_manifest() {
  manifest_.Clear();
}
inline const ::PricingDescriptor& ProductPricing::manifest(int index) const {
  // @@protoc_insertion_point(field_get:ProductPricing.manifest)
  return manifest_.Get(index);
}
inline ::PricingDescriptor* ProductPricing::mutable_manifest(int index) {
  // @@protoc_insertion_point(field_mutable:ProductPricing.manifest)
  return manifest_.Mutable(index);
}
inline ::PricingDescriptor* ProductPricing::add_manifest() {
  // @@protoc_insertion_point(field_add:ProductPricing.manifest)
  return manifest_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::PricingDescriptor >*
ProductPricing::mutable_manifest() {
  // @@protoc_insertion_point(field_mutable_list:ProductPricing.manifest)
  return &manifest_;
}
inline const ::google::protobuf::RepeatedPtrField< ::PricingDescriptor >&
ProductPricing::manifest() const {
  // @@protoc_insertion_point(field_list:ProductPricing.manifest)
  return manifest_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::PricingType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PricingType>() {
  return ::PricingType_descriptor();
}
template <> struct is_proto_enum< ::PricingWeightTier> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PricingWeightTier>() {
  return ::PricingWeightTier_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_structs_2fpricing_2fPricingDescriptor_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: structs/pricing/PricingDescriptor.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "structs/pricing/PricingDescriptor.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
class PricingTierAvailabilityDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PricingTierAvailability> {
} _PricingTierAvailability_default_instance_;
class UnitPricingDescriptorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<UnitPricingDescriptor> {
} _UnitPricingDescriptor_default_instance_;
class WeightedPricingDescriptorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<WeightedPricingDescriptor> {
} _WeightedPricingDescriptor_default_instance_;
class FreebiePricingDescriptorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<FreebiePricingDescriptor> {
} _FreebiePricingDescriptor_default_instance_;
class PricingDescriptorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PricingDescriptor> {
} _PricingDescriptor_default_instance_;
class ProductPricingDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ProductPricing> {
} _ProductPricing_default_instance_;

namespace protobuf_structs_2fpricing_2fPricingDescriptor_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[6];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[2];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PricingTierAvailability, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PricingTierAvailability, offered_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PricingTierAvailability, available_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnitPricingDescriptor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnitPricingDescriptor, price_value_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnitPricingDescriptor, status_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnitPricingDescriptor, discounts_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WeightedPricingDescriptor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WeightedPricingDescriptor, weight_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WeightedPricingDescriptor, tier_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WeightedPricingDescriptor, weightingrams_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FreebiePricingDescriptor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PricingDescriptor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PricingDescriptor, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PricingDescriptor, unit_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PricingDescriptor, weighted_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PricingDescriptor, freebie_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProductPricing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProductPricing, discounts_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProductPricing, manifest_),
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, -1, sizeof(PricingTierAvailability)},
  { 7, -1, sizeof(UnitPricingDescriptor)},
  { 15, -1, sizeof(WeightedPricingDescriptor)},
  { 23, -1, sizeof(FreebiePricingDescriptor)},
  { 28, -1, sizeof(PricingDescriptor)},
  { 37, -1, sizeof(ProductPricing)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_PricingTierAvailability_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_UnitPricingDescriptor_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_WeightedPricingDescriptor_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_FreebiePricingDescriptor_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PricingDescriptor_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ProductPricing_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "structs/pricing/PricingDescriptor.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 6);
}

}  // namespace

void TableStruct::Shutdown() {
  _PricingTierAvailability_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _UnitPricingDescriptor_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _WeightedPricingDescriptor_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _FreebiePricingDescriptor_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _PricingDescriptor_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _ProductPricing_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::protobuf_structs_2fpricing_2fSaleDescriptor_2eproto::InitDefaults();
  _PricingTierAvailability_default_instance_.DefaultConstruct();
  _UnitPricingDescriptor_default_instance_.DefaultConstruct();
  _WeightedPricingDescriptor_default_instance_.DefaultConstruct();
  _FreebiePricingDescriptor_default_instance_.DefaultConstruct();
  _PricingDescriptor_default_instance_.DefaultConstruct();
  _ProductPricing_default_instance_.DefaultConstruct();
  _UnitPricingDescriptor_default_instance_.get_mutable()->status_ = const_cast< ::PricingTierAvailability*>(
      ::PricingTierAvailability::internal_default_instance());
  _WeightedPricingDescriptor_default_instance_.get_mutable()->tier_ = const_cast< ::UnitPricingDescriptor*>(
      ::UnitPricingDescriptor::internal_default_instance());
  _PricingDescriptor_default_instance_.get_mutable()->unit_ = const_cast< ::UnitPricingDescriptor*>(
      ::UnitPricingDescriptor::internal_default_instance());
  _PricingDescriptor_default_instance_.get_mutable()->weighted_ = const_cast< ::WeightedPricingDescriptor*>(
      ::WeightedPricingDescriptor::internal_default_instance());
  _PricingDescriptor_default_instance_.get_mutable()->freebie_ = const_cast< ::FreebiePricingDescriptor*>(
      ::FreebiePricingDescriptor::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\'structs/pricing/PricingDescriptor.prot"
      "o\032$structs/pricing/SaleDescriptor.proto\""
      "=\n\027PricingTierAvailability\022\017\n\007offered\030\001 "
      "\001(\010\022\021\n\tavailable\030\002 \001(\010\"z\n\025UnitPricingDes"
      "criptor\022\023\n\013price_value\030\001 \001(\002\022(\n\006status\030\002"
      " \001(\0132\030.PricingTierAvailability\022\"\n\tdiscou"
      "nts\030\003 \003(\0132\017.SaleDescriptor\"|\n\031WeightedPr"
      "icingDescriptor\022\"\n\006weight\030\001 \001(\0162\022.Pricin"
      "gWeightTier\022$\n\004tier\030\002 \001(\0132\026.UnitPricingD"
      "escriptor\022\025\n\rweightInGrams\030\003 \001(\002\"\032\n\030Free"
      "biePricingDescriptor\"\257\001\n\021PricingDescript"
      "or\022\032\n\004type\030\001 \001(\0162\014.PricingType\022$\n\004unit\030\024"
      " \001(\0132\026.UnitPricingDescriptor\022,\n\010weighted"
      "\030\025 \001(\0132\032.WeightedPricingDescriptor\022*\n\007fr"
      "eebie\030\026 \001(\0132\031.FreebiePricingDescriptor\"Z"
      "\n\016ProductPricing\022\"\n\tdiscounts\030\001 \003(\0132\017.Sa"
      "leDescriptor\022$\n\010manifest\030\002 \003(\0132\022.Pricing"
      "Descriptor*2\n\013PricingType\022\010\n\004UNIT\020\000\022\014\n\010W"
      "EIGHTED\020\001\022\013\n\007FREEBIE\020\002*\211\001\n\021PricingWeight"
      "Tier\022\t\n\005OTHER\020\000\022\010\n\004GRAM\020\001\022\014\n\010HALFGRAM\020\002\022"
      "\017\n\013QUARTERGRAM\020\003\022\007\n\003DUB\020\004\022\n\n\006EIGHTH\020\005\022\013\n"
      "\007QUARTER\020\006\022\010\n\004HALF\020\007\022\t\n\005OUNCE\020\010\022\t\n\005POUND"
      "\020\tB%\n!io.bloombox.schema.product.structP"
      "\001b\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 929);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "structs/pricing/PricingDescriptor.proto", &protobuf_RegisterTypes);
  ::protobuf_structs_2fpricing_2fSaleDescriptor_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_structs_2fpricing_2fPricingDescriptor_2eproto

const ::google::protobuf::EnumDescriptor* PricingType_descriptor() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_enum_descriptors[0];
}
bool PricingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PricingWeightTier_descriptor() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_enum_descriptors[1];
}
bool PricingWeightTier_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PricingTierAvailability::kOfferedFieldNumber;
const int PricingTierAvailability::kAvailableFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PricingTierAvailability::PricingTierAvailability()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:PricingTierAvailability)
}
PricingTierAvailability::PricingTierAvailability(const PricingTierAvailability& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&offered_, &from.offered_,
    reinterpret_cast<char*>(&available_) -
    reinterpret_cast<char*>(&offered_) + sizeof(available_));
  // @@protoc_insertion_point(copy_constructor:PricingTierAvailability)
}

void PricingTierAvailability::SharedCtor() {
  ::memset(&offered_, 0, reinterpret_cast<char*>(&available_) -
    reinterpret_cast<char*>(&offered_) + sizeof(available_));
  _cached_size_ = 0;
}

PricingTierAvailability::~PricingTierAvailability() {
  // @@protoc_insertion_point(destructor:PricingTierAvailability)
  SharedDtor();
}

void PricingTierAvailability::SharedDtor() {
}

void PricingTierAvailability::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PricingTierAvailability::descriptor() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PricingTierAvailability& PricingTierAvailability::default_instance() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::InitDefaults();
  return *internal_default_instance();
}

PricingTierAvailability* PricingTierAvailability::New(::google::protobuf::Arena* arena) const {
  PricingTierAvailability* n = new PricingTierAvailability;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PricingTierAvailability::Clear() {
// @@protoc_insertion_point(message_clear_start:PricingTierAvailability)
  ::memset(&offered_, 0, reinterpret_cast<char*>(&available_) -
    reinterpret_cast<char*>(&offered_) + sizeof(available_));
}

bool PricingTierAvailability::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PricingTierAvailability)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // bool offered = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &offered_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool available = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &available_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PricingTierAvailability)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PricingTierAvailability)
  return false;
#undef DO_
}

void PricingTierAvailability::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PricingTierAvailability)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool offered = 1;
  if (this->offered() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->offered(), output);
  }

  // bool available = 2;
  if (this->available() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->available(), output);
  }

  // @@protoc_insertion_point(serialize_end:PricingTierAvailability)
}

::google::protobuf::uint8* PricingTierAvailability::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:PricingTierAvailability)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool offered = 1;
  if (this->offered() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->offered(), target);
  }

  // bool available = 2;
  if (this->available() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->available(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:PricingTierAvailability)
  return target;
}

size_t PricingTierAvailability::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PricingTierAvailability)
  size_t total_size = 0;

  // bool offered = 1;
  if (this->offered() != 0) {
    total_size += 1 + 1;
  }

  // bool available = 2;
  if (this->available() != 0) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PricingTierAvailability::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:PricingTierAvailability)
  GOOGLE_DCHECK_NE(&from, this);
  const PricingTierAvailability* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PricingTierAvailability>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:PricingTierAvailability)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:PricingTierAvailability)
    MergeFrom(*source);
  }
}

void PricingTierAvailability::MergeFrom(const PricingTierAvailability& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PricingTierAvailability)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.offered() != 0) {
    set_offered(from.offered());
  }
  if (from.available() != 0) {
    set_available(from.available());
  }
}

void PricingTierAvailability::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:PricingTierAvailability)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PricingTierAvailability::CopyFrom(const PricingTierAvailability& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PricingTierAvailability)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PricingTierAvailability::IsInitialized() const {
  return true;
}

void PricingTierAvailability::Swap(PricingTierAvailability* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PricingTierAvailability::InternalSwap(PricingTierAvailability* other) {
  std::swap(offered_, other->offered_);
  std::swap(available_, other->available_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PricingTierAvailability::GetMetadata() const {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PricingTierAvailability

// bool offered = 1;
void PricingTierAvailability::clear_offered() {
  offered_ = false;
}
bool PricingTierAvailability::offered() const {
  // @@protoc_insertion_point(field_get:PricingTierAvailability.offered)
  return offered_;
}
void PricingTierAvailability::set_offered(bool value) {
  
  offered_ = value;
  // @@protoc_insertion_point(field_set:PricingTierAvailability.offered)
}

// bool available = 2;
void PricingTierAvailability::clear_available() {
  available_ = false;
}
bool PricingTierAvailability::available() const {
  // @@protoc_insertion_point(field_get:PricingTierAvailability.available)
  return available_;
}
void PricingTierAvailability::set_available(bool value) {
  
  available_ = value;
  // @@protoc_insertion_point(field_set:PricingTierAvailability.available)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UnitPricingDescriptor::kPriceValueFieldNumber;
const int UnitPricingDescriptor::kStatusFieldNumber;
const int UnitPricingDescriptor::kDiscountsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UnitPricingDescriptor::UnitPricingDescriptor()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:UnitPricingDescriptor)
}
UnitPricingDescriptor::UnitPricingDescriptor(const UnitPricingDescriptor& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      discounts_(from.discounts_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_status()) {
    status_ = new ::PricingTierAvailability(*from.status_);
  } else {
    status_ = NULL;
  }
  price_value_ = from.price_value_;
  // @@protoc_insertion_point(copy_constructor:UnitPricingDescriptor)
}

void UnitPricingDescriptor::SharedCtor() {
  ::memset(&status_, 0, reinterpret_cast<char*>(&price_value_) -
    reinterpret_cast<char*>(&status_) + sizeof(price_value_));
  _cached_size_ = 0;
}

UnitPricingDescriptor::~UnitPricingDescriptor() {
  // @@protoc_insertion_point(destructor:UnitPricingDescriptor)
  SharedDtor();
}

void UnitPricingDescriptor::SharedDtor() {
  if (this != internal_default_instance()) {
    delete status_;
  }
}

void UnitPricingDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnitPricingDescriptor::descriptor() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const UnitPricingDescriptor& UnitPricingDescriptor::default_instance() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::InitDefaults();
  return *internal_default_instance();
}

UnitPricingDescriptor* UnitPricingDescriptor::New(::google::protobuf::Arena* arena) const {
  UnitPricingDescriptor* n = new UnitPricingDescriptor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UnitPricingDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:UnitPricingDescriptor)
  discounts_.Clear();
  if (GetArenaNoVirtual() == NULL && status_ != NULL) {
    delete status_;
  }
  status_ = NULL;
  price_value_ = 0;
}

bool UnitPricingDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:UnitPricingDescriptor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float price_value = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &price_value_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .PricingTierAvailability status = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .SaleDescriptor discounts = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_discounts()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:UnitPricingDescriptor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:UnitPricingDescriptor)
  return false;
#undef DO_
}

void UnitPricingDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:UnitPricingDescriptor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float price_value = 1;
  if (this->price_value() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->price_value(), output);
  }

  // .PricingTierAvailability status = 2;
  if (this->has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->status_, output);
  }

  // repeated .SaleDescriptor discounts = 3;
  for (unsigned int i = 0, n = this->discounts_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->discounts(i), output);
  }

  // @@protoc_insertion_point(serialize_end:UnitPricingDescriptor)
}

::google::protobuf::uint8* UnitPricingDescriptor::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:UnitPricingDescriptor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float price_value = 1;
  if (this->price_value() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->price_value(), target);
  }

  // .PricingTierAvailability status = 2;
  if (this->has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->status_, deterministic, target);
  }

  // repeated .SaleDescriptor discounts = 3;
  for (unsigned int i = 0, n = this->discounts_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->discounts(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:UnitPricingDescriptor)
  return target;
}

size_t UnitPricingDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UnitPricingDescriptor)
  size_t total_size = 0;

  // repeated .SaleDescriptor discounts = 3;
  {
    unsigned int count = this->discounts_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->discounts(i));
    }
  }

  // .PricingTierAvailability status = 2;
  if (this->has_status()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->status_);
  }

  // float price_value = 1;
  if (this->price_value() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnitPricingDescriptor::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:UnitPricingDescriptor)
  GOOGLE_DCHECK_NE(&from, this);
  const UnitPricingDescriptor* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const UnitPricingDescriptor>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:UnitPricingDescriptor)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:UnitPricingDescriptor)
    MergeFrom(*source);
  }
}

void UnitPricingDescriptor::MergeFrom(const UnitPricingDescriptor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:UnitPricingDescriptor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  discounts_.MergeFrom(from.discounts_);
  if (from.has_status()) {
    mutable_status()->::PricingTierAvailability::MergeFrom(from.status());
  }
  if (from.price_value() != 0) {
    set_price_value(from.price_value());
  }
}

void UnitPricingDescriptor::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:UnitPricingDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnitPricingDescriptor::CopyFrom(const UnitPricingDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UnitPricingDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnitPricingDescriptor::IsInitialized() const {
  return true;
}

void UnitPricingDescriptor::Swap(UnitPricingDescriptor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UnitPricingDescriptor::InternalSwap(UnitPricingDescriptor* other) {
  discounts_.InternalSwap(&other->discounts_);
  std::swap(status_, other->status_);
  std::swap(price_value_, other->price_value_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata UnitPricingDescriptor::GetMetadata() const {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UnitPricingDescriptor

// float price_value = 1;
void UnitPricingDescriptor::clear_price_value() {
  price_value_ = 0;
}
float UnitPricingDescriptor::price_value() const {
  // @@protoc_insertion_point(field_get:UnitPricingDescriptor.price_value)
  return price_value_;
}
void UnitPricingDescriptor::set_price_value(float value) {
  
  price_value_ = value;
  // @@protoc_insertion_point(field_set:UnitPricingDescriptor.price_value)
}

// .PricingTierAvailability status = 2;
bool UnitPricingDescriptor::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
void UnitPricingDescriptor::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) delete status_;
  status_ = NULL;
}
const ::PricingTierAvailability& UnitPricingDescriptor::status() const {
  // @@protoc_insertion_point(field_get:UnitPricingDescriptor.status)
  return status_ != NULL ? *status_
                         : *::PricingTierAvailability::internal_default_instance();
}
::PricingTierAvailability* UnitPricingDescriptor::mutable_status() {
  
  if (status_ == NULL) {
    status_ = new ::PricingTierAvailability;
  }
  // @@protoc_insertion_point(field_mutable:UnitPricingDescriptor.status)
  return status_;
}
::PricingTierAvailability* UnitPricingDescriptor::release_status() {
  // @@protoc_insertion_point(field_release:UnitPricingDescriptor.status)
  
  ::PricingTierAvailability* temp = status_;
  status_ = NULL;
  return temp;
}
void UnitPricingDescriptor::set_allocated_status(::PricingTierAvailability* status) {
  delete status_;
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:UnitPricingDescriptor.status)
}

// repeated .SaleDescriptor discounts = 3;
int UnitPricingDescriptor::discounts_size() const {
  return discounts_.size();
}
void UnitPricingDescriptor::clear_discounts() {
  discounts_.Clear();
}
const ::SaleDescriptor& UnitPricingDescriptor::discounts(int index) const {
  // @@protoc_insertion_point(field_get:UnitPricingDescriptor.discounts)
  return discounts_.Get(index);
}
::SaleDescriptor* UnitPricingDescriptor::mutable_discounts(int index) {
  // @@protoc_insertion_point(field_mutable:UnitPricingDescriptor.discounts)
  return discounts_.Mutable(index);
}
::SaleDescriptor* UnitPricingDescriptor::add_discounts() {
  // @@protoc_insertion_point(field_add:UnitPricingDescriptor.discounts)
  return discounts_.Add();
}
::google::protobuf::RepeatedPtrField< ::SaleDescriptor >*
UnitPricingDescriptor::mutable_discounts() {
  // @@protoc_insertion_point(field_mutable_list:UnitPricingDescriptor.discounts)
  return &discounts_;
}
const ::google::protobuf::RepeatedPtrField< ::SaleDescriptor >&
UnitPricingDescriptor::discounts() const {
  // @@protoc_insertion_point(field_list:UnitPricingDescriptor.discounts)
  return discounts_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int WeightedPricingDescriptor::kWeightFieldNumber;
const int WeightedPricingDescriptor::kTierFieldNumber;
const int WeightedPricingDescriptor::kWeightInGramsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

WeightedPricingDescriptor::WeightedPricingDescriptor()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:WeightedPricingDescriptor)
}
WeightedPricingDescriptor::WeightedPricingDescriptor(const WeightedPricingDescriptor& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_tier()) {
    tier_ = new ::UnitPricingDescriptor(*from.tier_);
  } else {
    tier_ = NULL;
  }
  ::memcpy(&weight_, &from.weight_,
    reinterpret_cast<char*>(&weightingrams_) -
    reinterpret_cast<char*>(&weight_) + sizeof(weightingrams_));
  // @@protoc_insertion_point(copy_constructor:WeightedPricingDescriptor)
}

void WeightedPricingDescriptor::SharedCtor() {
  ::memset(&tier_, 0, reinterpret_cast<char*>(&weightingrams_) -
    reinterpret_cast<char*>(&tier_) + sizeof(weightingrams_));
  _cached_size_ = 0;
}

WeightedPricingDescriptor::~WeightedPricingDescriptor() {
  // @@protoc_insertion_point(destructor:WeightedPricingDescriptor)
  SharedDtor();
}

void WeightedPricingDescriptor::SharedDtor() {
  if (this != internal_default_instance()) {
    delete tier_;
  }
}

void WeightedPricingDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WeightedPricingDescriptor::descriptor() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const WeightedPricingDescriptor& WeightedPricingDescriptor::default_instance() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::InitDefaults();
  return *internal_default_instance();
}

WeightedPricingDescriptor* WeightedPricingDescriptor::New(::google::protobuf::Arena* arena) const {
  WeightedPricingDescriptor* n = new WeightedPricingDescriptor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void WeightedPricingDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:WeightedPricingDescriptor)
  if (GetArenaNoVirtual() == NULL && tier_ != NULL) {
    delete tier_;
  }
  tier_ = NULL;
  ::memset(&weight_, 0, reinterpret_cast<char*>(&weightingrams_) -
    reinterpret_cast<char*>(&weight_) + sizeof(weightingrams_));
}

bool WeightedPricingDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:WeightedPricingDescriptor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .PricingWeightTier weight = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_weight(static_cast< ::PricingWeightTier >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .UnitPricingDescriptor tier = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tier()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float weightInGrams = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weightingrams_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:WeightedPricingDescriptor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:WeightedPricingDescriptor)
  return false;
#undef DO_
}

void WeightedPricingDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:WeightedPricingDescriptor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .PricingWeightTier weight = 1;
  if (this->weight() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->weight(), output);
  }

  // .UnitPricingDescriptor tier = 2;
  if (this->has_tier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->tier_, output);
  }

  // float weightInGrams = 3;
  if (this->weightingrams() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->weightingrams(), output);
  }

  // @@protoc_insertion_point(serialize_end:WeightedPricingDescriptor)
}

::google::protobuf::uint8* WeightedPricingDescriptor::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:WeightedPricingDescriptor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .PricingWeightTier weight = 1;
  if (this->weight() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->weight(), target);
  }

  // .UnitPricingDescriptor tier = 2;
  if (this->has_tier()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->tier_, deterministic, target);
  }

  // float weightInGrams = 3;
  if (this->weightingrams() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->weightingrams(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:WeightedPricingDescriptor)
  return target;
}

size_t WeightedPricingDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:WeightedPricingDescriptor)
  size_t total_size = 0;

  // .UnitPricingDescriptor tier = 2;
  if (this->has_tier()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->tier_);
  }

  // .PricingWeightTier weight = 1;
  if (this->weight() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->weight());
  }

  // float weightInGrams = 3;
  if (this->weightingrams() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WeightedPricingDescriptor::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:WeightedPricingDescriptor)
  GOOGLE_DCHECK_NE(&from, this);
  const WeightedPricingDescriptor* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const WeightedPricingDescriptor>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:WeightedPricingDescriptor)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:WeightedPricingDescriptor)
    MergeFrom(*source);
  }
}

void WeightedPricingDescriptor::MergeFrom(const WeightedPricingDescriptor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:WeightedPricingDescriptor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_tier()) {
    mutable_tier()->::UnitPricingDescriptor::MergeFrom(from.tier());
  }
  if (from.weight() != 0) {
    set_weight(from.weight());
  }
  if (from.weightingrams() != 0) {
    set_weightingrams(from.weightingrams());
  }
}

void WeightedPricingDescriptor::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:WeightedPricingDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WeightedPricingDescriptor::CopyFrom(const WeightedPricingDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:WeightedPricingDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WeightedPricingDescriptor::IsInitialized() const {
  return true;
}

void WeightedPricingDescriptor::Swap(WeightedPricingDescriptor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void WeightedPricingDescriptor::InternalSwap(WeightedPricingDescriptor* other) {
  std::swap(tier_, other->tier_);
  std::swap(weight_, other->weight_);
  std::swap(weightingrams_, other->weightingrams_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata WeightedPricingDescriptor::GetMetadata() const {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// WeightedPricingDescriptor

// .PricingWeightTier weight = 1;
void WeightedPricingDescriptor::clear_weight() {
  weight_ = 0;
}
::PricingWeightTier WeightedPricingDescriptor::weight() const {
  // @@protoc_insertion_point(field_get:WeightedPricingDescriptor.weight)
  return static_cast< ::PricingWeightTier >(weight_);
}
void WeightedPricingDescriptor::set_weight(::PricingWeightTier value) {
  
  weight_ = value;
  // @@protoc_insertion_point(field_set:WeightedPricingDescriptor.weight)
}

// .UnitPricingDescriptor tier = 2;
bool WeightedPricingDescriptor::has_tier() const {
  return this != internal_default_instance() && tier_ != NULL;
}
void WeightedPricingDescriptor::clear_tier() {
  if (GetArenaNoVirtual() == NULL && tier_ != NULL) delete tier_;
  tier_ = NULL;
}
const ::UnitPricingDescriptor& WeightedPricingDescriptor::tier() const {
  // @@protoc_insertion_point(field_get:WeightedPricingDescriptor.tier)
  return tier_ != NULL ? *tier_
                         : *::UnitPricingDescriptor::internal_default_instance();
}
::UnitPricingDescriptor* WeightedPricingDescriptor::mutable_tier() {
  
  if (tier_ == NULL) {
    tier_ = new ::UnitPricingDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:WeightedPricingDescriptor.tier)
  return tier_;
}
::UnitPricingDescriptor* WeightedPricingDescriptor::release_tier() {
  // @@protoc_insertion_point(field_release:WeightedPricingDescriptor.tier)
  
  ::UnitPricingDescriptor* temp = tier_;
  tier_ = NULL;
  return temp;
}
void WeightedPricingDescriptor::set_allocated_tier(::UnitPricingDescriptor* tier) {
  delete tier_;
  tier_ = tier;
  if (tier) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:WeightedPricingDescriptor.tier)
}

// float weightInGrams = 3;
void WeightedPricingDescriptor::clear_weightingrams() {
  weightingrams_ = 0;
}
float WeightedPricingDescriptor::weightingrams() const {
  // @@protoc_insertion_point(field_get:WeightedPricingDescriptor.weightInGrams)
  return weightingrams_;
}
void WeightedPricingDescriptor::set_weightingrams(float value) {
  
  weightingrams_ = value;
  // @@protoc_insertion_point(field_set:WeightedPricingDescriptor.weightInGrams)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FreebiePricingDescriptor::FreebiePricingDescriptor()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:FreebiePricingDescriptor)
}
FreebiePricingDescriptor::FreebiePricingDescriptor(const FreebiePricingDescriptor& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:FreebiePricingDescriptor)
}

void FreebiePricingDescriptor::SharedCtor() {
  _cached_size_ = 0;
}

FreebiePricingDescriptor::~FreebiePricingDescriptor() {
  // @@protoc_insertion_point(destructor:FreebiePricingDescriptor)
  SharedDtor();
}

void FreebiePricingDescriptor::SharedDtor() {
}

void FreebiePricingDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FreebiePricingDescriptor::descriptor() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const FreebiePricingDescriptor& FreebiePricingDescriptor::default_instance() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::InitDefaults();
  return *internal_default_instance();
}

FreebiePricingDescriptor* FreebiePricingDescriptor::New(::google::protobuf::Arena* arena) const {
  FreebiePricingDescriptor* n = new FreebiePricingDescriptor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FreebiePricingDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:FreebiePricingDescriptor)
}

bool FreebiePricingDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:FreebiePricingDescriptor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:FreebiePricingDescriptor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FreebiePricingDescriptor)
  return false;
#undef DO_
}

void FreebiePricingDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FreebiePricingDescriptor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // @@protoc_insertion_point(serialize_end:FreebiePricingDescriptor)
}

::google::protobuf::uint8* FreebiePricingDescriptor::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:FreebiePricingDescriptor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // @@protoc_insertion_point(serialize_to_array_end:FreebiePricingDescriptor)
  return target;
}

size_t FreebiePricingDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:FreebiePricingDescriptor)
  size_t total_size = 0;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FreebiePricingDescriptor::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:FreebiePricingDescriptor)
  GOOGLE_DCHECK_NE(&from, this);
  const FreebiePricingDescriptor* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const FreebiePricingDescriptor>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:FreebiePricingDescriptor)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:FreebiePricingDescriptor)
    MergeFrom(*source);
  }
}

void FreebiePricingDescriptor::MergeFrom(const FreebiePricingDescriptor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:FreebiePricingDescriptor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void FreebiePricingDescriptor::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:FreebiePricingDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FreebiePricingDescriptor::CopyFrom(const FreebiePricingDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:FreebiePricingDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FreebiePricingDescriptor::IsInitialized() const {
  return true;
}

void FreebiePricingDescriptor::Swap(FreebiePricingDescriptor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FreebiePricingDescriptor::InternalSwap(FreebiePricingDescriptor* other) {
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FreebiePricingDescriptor::GetMetadata() const {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FreebiePricingDescriptor

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PricingDescriptor::kTypeFieldNumber;
const int PricingDescriptor::kUnitFieldNumber;
const int PricingDescriptor::kWeightedFieldNumber;
const int PricingDescriptor::kFreebieFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PricingDescriptor::PricingDescriptor()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:PricingDescriptor)
}
PricingDescriptor::PricingDescriptor(const PricingDescriptor& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_unit()) {
    unit_ = new ::UnitPricingDescriptor(*from.unit_);
  } else {
    unit_ = NULL;
  }
  if (from.has_weighted()) {
    weighted_ = new ::WeightedPricingDescriptor(*from.weighted_);
  } else {
    weighted_ = NULL;
  }
  if (from.has_freebie()) {
    freebie_ = new ::FreebiePricingDescriptor(*from.freebie_);
  } else {
    freebie_ = NULL;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:PricingDescriptor)
}

void PricingDescriptor::SharedCtor() {
  ::memset(&unit_, 0, reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&unit_) + sizeof(type_));
  _cached_size_ = 0;
}

PricingDescriptor::~PricingDescriptor() {
  // @@protoc_insertion_point(destructor:PricingDescriptor)
  SharedDtor();
}

void PricingDescriptor::SharedDtor() {
  if (this != internal_default_instance()) {
    delete unit_;
  }
  if (this != internal_default_instance()) {
    delete weighted_;
  }
  if (this != internal_default_instance()) {
    delete freebie_;
  }
}

void PricingDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PricingDescriptor::descriptor() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PricingDescriptor& PricingDescriptor::default_instance() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::InitDefaults();
  return *internal_default_instance();
}

PricingDescriptor* PricingDescriptor::New(::google::protobuf::Arena* arena) const {
  PricingDescriptor* n = new PricingDescriptor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PricingDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:PricingDescriptor)
  if (GetArenaNoVirtual() == NULL && unit_ != NULL) {
    delete unit_;
  }
  unit_ = NULL;
  if (GetArenaNoVirtual() == NULL && weighted_ != NULL) {
    delete weighted_;
  }
  weighted_ = NULL;
  if (GetArenaNoVirtual() == NULL && freebie_ != NULL) {
    delete freebie_;
  }
  freebie_ = NULL;
  type_ = 0;
}

bool PricingDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:PricingDescriptor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .PricingType type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::PricingType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .UnitPricingDescriptor unit = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(162u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .WeightedPricingDescriptor weighted = 21;
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(170u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_weighted()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .FreebiePricingDescriptor freebie = 22;
      case 22: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(178u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_freebie()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:PricingDescriptor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:PricingDescriptor)
  return false;
#undef DO_
}

void PricingDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:PricingDescriptor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .PricingType type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // .UnitPricingDescriptor unit = 20;
  if (this->has_unit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, *this->unit_, output);
  }

  // .WeightedPricingDescriptor weighted = 21;
  if (this->has_weighted()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, *this->weighted_, output);
  }

  // .FreebiePricingDescriptor freebie = 22;
  if (this->has_freebie()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      22, *this->freebie_, output);
  }

  // @@protoc_insertion_point(serialize_end:PricingDescriptor)
}

::google::protobuf::uint8* PricingDescriptor::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:PricingDescriptor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .PricingType type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // .UnitPricingDescriptor unit = 20;
  if (this->has_unit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        20, *this->unit_, deterministic, target);
  }

  // .WeightedPricingDescriptor weighted = 21;
  if (this->has_weighted()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        21, *this->weighted_, deterministic, target);
  }

  // .FreebiePricingDescriptor freebie = 22;
  if (this->has_freebie()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        22, *this->freebie_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:PricingDescriptor)
  return target;
}

size_t PricingDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PricingDescriptor)
  size_t total_size = 0;

  // .UnitPricingDescriptor unit = 20;
  if (this->has_unit()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->unit_);
  }

  // .WeightedPricingDescriptor weighted = 21;
  if (this->has_weighted()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->weighted_);
  }

  // .FreebiePricingDescriptor freebie = 22;
  if (this->has_freebie()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->freebie_);
  }

  // .PricingType type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PricingDescriptor::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:PricingDescriptor)
  GOOGLE_DCHECK_NE(&from, this);
  const PricingDescriptor* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PricingDescriptor>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:PricingDescriptor)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:PricingDescriptor)
    MergeFrom(*source);
  }
}

void PricingDescriptor::MergeFrom(const PricingDescriptor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PricingDescriptor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_unit()) {
    mutable_unit()->::UnitPricingDescriptor::MergeFrom(from.unit());
  }
  if (from.has_weighted()) {
    mutable_weighted()->::WeightedPricingDescriptor::MergeFrom(from.weighted());
  }
  if (from.has_freebie()) {
    mutable_freebie()->::FreebiePricingDescriptor::MergeFrom(from.freebie());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
}

void PricingDescriptor::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:PricingDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PricingDescriptor::CopyFrom(const PricingDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PricingDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PricingDescriptor::IsInitialized() const {
  return true;
}

void PricingDescriptor::Swap(PricingDescriptor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PricingDescriptor::InternalSwap(PricingDescriptor* other) {
  std::swap(unit_, other->unit_);
  std::swap(weighted_, other->weighted_);
  std::swap(freebie_, other->freebie_);
  std::swap(type_, other->type_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PricingDescriptor::GetMetadata() const {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PricingDescriptor

// .PricingType type = 1;
void PricingDescriptor::clear_type() {
  type_ = 0;
}
::PricingType PricingDescriptor::type() const {
  // @@protoc_insertion_point(field_get:PricingDescriptor.type)
  return static_cast< ::PricingType >(type_);
}
void PricingDescriptor::set_type(::PricingType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:PricingDescriptor.type)
}

// .UnitPricingDescriptor unit = 20;
bool PricingDescriptor::has_unit() const {
  return this != internal_default_instance() && unit_ != NULL;
}
void PricingDescriptor::clear_unit() {
  if (GetArenaNoVirtual() == NULL && unit_ != NULL) delete unit_;
  unit_ = NULL;
}
const ::UnitPricingDescriptor& PricingDescriptor::unit() const {
  // @@protoc_insertion_point(field_get:PricingDescriptor.unit)
  return unit_ != NULL ? *unit_
                         : *::UnitPricingDescriptor::internal_default_instance();
}
::UnitPricingDescriptor* PricingDescriptor::mutable_unit() {
  
  if (unit_ == NULL) {
    unit_ = new ::UnitPricingDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:PricingDescriptor.unit)
  return unit_;
}
::UnitPricingDescriptor* PricingDescriptor::release_unit() {
  // @@protoc_insertion_point(field_release:PricingDescriptor.unit)
  
  ::UnitPricingDescriptor* temp = unit_;
  unit_ = NULL;
  return temp;
}
void PricingDescriptor::set_allocated_unit(::UnitPricingDescriptor* unit) {
  delete unit_;
  unit_ = unit;
  if (unit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PricingDescriptor.unit)
}

// .WeightedPricingDescriptor weighted = 21;
bool PricingDescriptor::has_weighted() const {
  return this != internal_default_instance() && weighted_ != NULL;
}
void PricingDescriptor::clear_weighted() {
  if (GetArenaNoVirtual() == NULL && weighted_ != NULL) delete weighted_;
  weighted_ = NULL;
}
const ::WeightedPricingDescriptor& PricingDescriptor::weighted() const {
  // @@protoc_insertion_point(field_get:PricingDescriptor.weighted)
  return weighted_ != NULL ? *weighted_
                         : *::WeightedPricingDescriptor::internal_default_instance();
}
::WeightedPricingDescriptor* PricingDescriptor::mutable_weighted() {
  
  if (weighted_ == NULL) {
    weighted_ = new ::WeightedPricingDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:PricingDescriptor.weighted)
  return weighted_;
}
::WeightedPricingDescriptor* PricingDescriptor::release_weighted() {
  // @@protoc_insertion_point(field_release:PricingDescriptor.weighted)
  
  ::WeightedPricingDescriptor* temp = weighted_;
  weighted_ = NULL;
  return temp;
}
void PricingDescriptor::set_allocated_weighted(::WeightedPricingDescriptor* weighted) {
  delete weighted_;
  weighted_ = weighted;
  if (weighted) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PricingDescriptor.weighted)
}

// .FreebiePricingDescriptor freebie = 22;
bool PricingDescriptor::has_freebie() const {
  return this != internal_default_instance() && freebie_ != NULL;
}
void PricingDescriptor::clear_freebie() {
  if (GetArenaNoVirtual() == NULL && freebie_ != NULL) delete freebie_;
  freebie_ = NULL;
}
const ::FreebiePricingDescriptor& PricingDescriptor::freebie() const {
  // @@protoc_insertion_point(field_get:PricingDescriptor.freebie)
  return freebie_ != NULL ? *freebie_
                         : *::FreebiePricingDescriptor::internal_default_instance();
}
::FreebiePricingDescriptor* PricingDescriptor::mutable_freebie() {
  
  if (freebie_ == NULL) {
    freebie_ = new ::FreebiePricingDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:PricingDescriptor.freebie)
  return freebie_;
}
::FreebiePricingDescriptor* PricingDescriptor::release_freebie() {
  // @@protoc_insertion_point(field_release:PricingDescriptor.freebie)
  
  ::FreebiePricingDescriptor* temp = freebie_;
  freebie_ = NULL;
  return temp;
}
void PricingDescriptor::set_allocated_freebie(::FreebiePricingDescriptor* freebie) {
  delete freebie_;
  freebie_ = freebie;
  if (freebie) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:PricingDescriptor.freebie)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ProductPricing::kDiscountsFieldNumber;
const int ProductPricing::kManifestFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ProductPricing::ProductPricing()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ProductPricing)
}
ProductPricing::ProductPricing(const ProductPricing& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      discounts_(from.discounts_),
      manifest_(from.manifest_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ProductPricing)
}

void ProductPricing::SharedCtor() {
  _cached_size_ = 0;
}

ProductPricing::~ProductPricing() {
  // @@protoc_insertion_point(destructor:ProductPricing)
  SharedDtor();
}

void ProductPricing::SharedDtor() {
}

void ProductPricing::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProductPricing::descriptor() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ProductPricing& ProductPricing::default_instance() {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::InitDefaults();
  return *internal_default_instance();
}

ProductPricing* ProductPricing::New(::google::protobuf::Arena* arena) const {
  ProductPricing* n = new ProductPricing;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ProductPricing::Clear() {
// @@protoc_insertion_point(message_clear_start:ProductPricing)
  discounts_.Clear();
  manifest_.Clear();
}

bool ProductPricing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ProductPricing)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .SaleDescriptor discounts = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_discounts()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .PricingDescriptor manifest = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_manifest()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ProductPricing)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ProductPricing)
  return false;
#undef DO_
}

void ProductPricing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ProductPricing)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .SaleDescriptor discounts = 1;
  for (unsigned int i = 0, n = this->discounts_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->discounts(i), output);
  }

  // repeated .PricingDescriptor manifest = 2;
  for (unsigned int i = 0, n = this->manifest_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->manifest(i), output);
  }

  // @@protoc_insertion_point(serialize_end:ProductPricing)
}

::google::protobuf::uint8* ProductPricing::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:ProductPricing)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .SaleDescriptor discounts = 1;
  for (unsigned int i = 0, n = this->discounts_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->discounts(i), deterministic, target);
  }

  // repeated .PricingDescriptor manifest = 2;
  for (unsigned int i = 0, n = this->manifest_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->manifest(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:ProductPricing)
  return target;
}

size_t ProductPricing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProductPricing)
  size_t total_size = 0;

  // repeated .SaleDescriptor discounts = 1;
  {
    unsigned int count = this->discounts_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->discounts(i));
    }
  }

  // repeated .PricingDescriptor manifest = 2;
  {
    unsigned int count = this->manifest_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->manifest(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProductPricing::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ProductPricing)
  GOOGLE_DCHECK_NE(&from, this);
  const ProductPricing* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ProductPricing>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ProductPricing)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ProductPricing)
    MergeFrom(*source);
  }
}

void ProductPricing::MergeFrom(const ProductPricing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ProductPricing)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  discounts_.MergeFrom(from.discounts_);
  manifest_.MergeFrom(from.manifest_);
}

void ProductPricing::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ProductPricing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProductPricing::CopyFrom(const ProductPricing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProductPricing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProductPricing::IsInitialized() const {
  return true;
}

void ProductPricing::Swap(ProductPricing* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ProductPricing::InternalSwap(ProductPricing* other) {
  discounts_.InternalSwap(&other->discounts_);
  manifest_.InternalSwap(&other->manifest_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ProductPricing::GetMetadata() const {
  protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_structs_2fpricing_2fPricingDescriptor_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ProductPricing

// repeated .SaleDescriptor discounts = 1;
int ProductPricing::discounts_size() const {
  return discounts_.size();
}
void ProductPricing::clear_discounts() {
  discounts_.Clear();
}
const ::SaleDescriptor& ProductPricing::discounts(int index) const {
  // @@protoc_insertion_point(field_get:ProductPricing.discounts)
  return discounts_.Get(index);
}
::SaleDescriptor* ProductPricing::mutable_discounts(int index) {
  // @@protoc_insertion_point(field_mutable:ProductPricing.discounts)
  return discounts_.Mutable(index);
}
::SaleDescriptor* ProductPricing::add_discounts() {
  // @@protoc_insertion_point(field_add:ProductPricing.discounts)
  return discounts_.Add();
}
::google::protobuf::RepeatedPtrField< ::SaleDescriptor >*
ProductPricing::mutable_discounts() {
  // @@protoc_insertion_point(field_mutable_list:ProductPricing.discounts)
  return &discounts_;
}
const ::google::protobuf::RepeatedPtrField< ::SaleDescriptor >&
ProductPricing::discounts() const {
  // @@protoc_insertion_point(field_list:ProductPricing.discounts)
  return discounts_;
}

// repeated .PricingDescriptor manifest = 2;
int ProductPricing::manifest_size() const {
  return manifest_.size();
}
void ProductPricing::clear_manifest() {
  manifest_.Clear();
}
const ::PricingDescriptor& ProductPricing::manifest(int index) const {
  // @@protoc_insertion_point(field_get:ProductPricing.manifest)
  return manifest_.Get(index);
}
::PricingDescriptor* ProductPricing::mutable_manifest(int index) {
  // @@protoc_insertion_point(field_mutable:ProductPricing.manifest)
  return manifest_.Mutable(index);
}
::PricingDescriptor* ProductPricing::add_manifest() {
  // @@protoc_insertion_point(field_add:ProductPricing.manifest)
  return manifest_.Add();
}
::google::protobuf::RepeatedPtrField< ::PricingDescriptor >*
ProductPricing::mutable_manifest() {
  // @@protoc_insertion_point(field_mutable_list:ProductPricing.manifest)
  return &manifest_;
}
const ::google::protobuf::RepeatedPtrField< ::PricingDescriptor >&
ProductPricing::manifest() const {
  // @@protoc_insertion_point(field_list:ProductPricing.manifest)
  return manifest_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: products/Flower.proto

#ifndef PROTOBUF_products_2fFlower_2eproto__INCLUDED
#define PROTOBUF_products_2fFlower_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "base/ProductKey.pb.h"
#include "content/MaterialsData.pb.h"
#include "content/ProductContent.pb.h"
#include "structs/FlagsDescriptor.pb.h"
#include "structs/pricing/PricingDescriptor.pb.h"
// @@protoc_insertion_point(includes)
class FlagsDescriptor;
class FlagsDescriptorDefaultTypeInternal;
extern FlagsDescriptorDefaultTypeInternal _FlagsDescriptor_default_instance_;
class Flower;
class FlowerDefaultTypeInternal;
extern FlowerDefaultTypeInternal _Flower_default_instance_;
class FreebiePricingDescriptor;
class FreebiePricingDescriptorDefaultTypeInternal;
extern FreebiePricingDescriptorDefaultTypeInternal _FreebiePricingDescriptor_default_instance_;
class MaterialsData;
class MaterialsDataDefaultTypeInternal;
extern MaterialsDataDefaultTypeInternal _MaterialsData_default_instance_;
class PricingDescriptor;
class PricingDescriptorDefaultTypeInternal;
extern PricingDescriptorDefaultTypeInternal _PricingDescriptor_default_instance_;
class PricingTierAvailability;
class PricingTierAvailabilityDefaultTypeInternal;
extern PricingTierAvailabilityDefaultTypeInternal _PricingTierAvailability_default_instance_;
class ProductContent;
class ProductContentDefaultTypeInternal;
extern ProductContentDefaultTypeInternal _ProductContent_default_instance_;
class ProductFlagValue;
class ProductFlagValueDefaultTypeInternal;
extern ProductFlagValueDefaultTypeInternal _ProductFlagValue_default_instance_;
class ProductFlagset;
class ProductFlagsetDefaultTypeInternal;
extern ProductFlagsetDefaultTypeInternal _ProductFlagset_default_instance_;
class ProductKey;
class ProductKeyDefaultTypeInternal;
extern ProductKeyDefaultTypeInternal _ProductKey_default_instance_;
class ProductPricing;
class ProductPricingDefaultTypeInternal;
extern ProductPricingDefaultTypeInternal _ProductPricing_default_instance_;
class UnitPricingDescriptor;
class UnitPricingDescriptorDefaultTypeInternal;
extern UnitPricingDescriptorDefaultTypeInternal _UnitPricingDescriptor_default_instance_;
class WeightedPricingDescriptor;
class WeightedPricingDescriptorDefaultTypeInternal;
extern WeightedPricingDescriptorDefaultTypeInternal _WeightedPricingDescriptor_default_instance_;

namespace protobuf_products_2fFlower_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_products_2fFlower_2eproto

// ===================================================================

class Flower : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Flower) */ {
 public:
  Flower();
  virtual ~Flower();

  Flower(const Flower& from);

  inline Flower& operator=(const Flower& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Flower& default_instance();

  static inline const Flower* internal_default_instance() {
    return reinterpret_cast<const Flower*>(
               &_Flower_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Flower* other);

  // implements Message ----------------------------------------------

  inline Flower* New() const PROTOBUF_FINAL { return New(NULL); }

  Flower* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Flower& from);
  void MergeFrom(const Flower& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Flower* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ProductKey key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::ProductKey& key() const;
  ::ProductKey* mutable_key();
  ::ProductKey* release_key();
  void set_allocated_key(::ProductKey* key);

  // .ProductContent product_data = 20;
  bool has_product_data() const;
  void clear_product_data();
  static const int kProductDataFieldNumber = 20;
  const ::ProductContent& product_data() const;
  ::ProductContent* mutable_product_data();
  ::ProductContent* release_product_data();
  void set_allocated_product_data(::ProductContent* product_data);

  // .MaterialsData material_data = 21;
  bool has_material_data() const;
  void clear_material_data();
  static const int kMaterialDataFieldNumber = 21;
  const ::MaterialsData& material_data() const;
  ::MaterialsData* mutable_material_data();
  ::MaterialsData* release_material_data();
  void set_allocated_material_data(::MaterialsData* material_data);

  // .FlagsDescriptor flags = 22;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 22;
  const ::FlagsDescriptor& flags() const;
  ::FlagsDescriptor* mutable_flags();
  ::FlagsDescriptor* release_flags();
  void set_allocated_flags(::FlagsDescriptor* flags);

  // .ProductPricing pricing = 23;
  bool has_pricing() const;
  void clear_pricing();
  static const int kPricingFieldNumber = 23;
  const ::ProductPricing& pricing() const;
  ::ProductPricing* mutable_pricing();
  ::ProductPricing* release_pricing();
  void set_allocated_pricing(::ProductPricing* pricing);

  // @@protoc_insertion_point(class_scope:Flower)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ProductKey* key_;
  ::ProductContent* product_data_;
  ::MaterialsData* material_data_;
  ::FlagsDescriptor* flags_;
  ::ProductPricing* pricing_;
  mutable int _cached_size_;
  friend struct protobuf_products_2fFlower_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Flower

// .ProductKey key = 1;
inline bool Flower::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline void Flower::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::ProductKey& Flower::key() const {
  // @@protoc_insertion_point(field_get:Flower.key)
  return key_ != NULL ? *key_
                         : *::ProductKey::internal_default_instance();
}
inline ::ProductKey* Flower::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::ProductKey;
  }
  // @@protoc_insertion_point(field_mutable:Flower.key)
  return key_;
}
inline ::ProductKey* Flower::release_key() {
  // @@protoc_insertion_point(field_release:Flower.key)
  
  ::ProductKey* temp = key_;
  key_ = NULL;
  return temp;
}
inline void Flower::set_allocated_key(::ProductKey* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Flower.key)
}

// .ProductContent product_data = 20;
inline bool Flower::has_product_data() const {
  return this != internal_default_instance() && product_data_ != NULL;
}
inline void Flower::clear_product_data() {
  if (GetArenaNoVirtual() == NULL && product_data_ != NULL) delete product_data_;
  product_data_ = NULL;
}
inline const ::ProductContent& Flower::product_data() const {
  // @@protoc_insertion_point(field_get:Flower.product_data)
  return product_data_ != NULL ? *product_data_
                         : *::ProductContent::internal_default_instance();
}
inline ::ProductContent* Flower::mutable_product_data() {
  
  if (product_data_ == NULL) {
    product_data_ = new ::ProductContent;
  }
  // @@protoc_insertion_point(field_mutable:Flower.product_data)
  return product_data_;
}
inline ::ProductContent* Flower::release_product_data() {
  // @@protoc_insertion_point(field_release:Flower.product_data)
  
  ::ProductContent* temp = product_data_;
  product_data_ = NULL;
  return temp;
}
inline void Flower::set_allocated_product_data(::ProductContent* product_data) {
  delete product_data_;
  product_data_ = product_data;
  if (product_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Flower.product_data)
}

// .MaterialsData material_data = 21;
inline bool Flower::has_material_data() const {
  return this != internal_default_instance() && material_data_ != NULL;
}
inline void Flower::clear_material_data() {
  if (GetArenaNoVirtual() == NULL && material_data_ != NULL) delete material_data_;
  material_data_ = NULL;
}
inline const ::MaterialsData& Flower::material_data() const {
  // @@protoc_insertion_point(field_get:Flower.material_data)
  return material_data_ != NULL ? *material_data_
                         : *::MaterialsData::internal_default_instance();
}
inline ::MaterialsData* Flower::mutable_material_data() {
  
  if (material_data_ == NULL) {
    material_data_ = new ::MaterialsData;
  }
  // @@protoc_insertion_point(field_mutable:Flower.material_data)
  return material_data_;
}
inline ::MaterialsData* Flower::release_material_data() {
  // @@protoc_insertion_point(field_release:Flower.material_data)
  
  ::MaterialsData* temp = material_data_;
  material_data_ = NULL;
  return temp;
}
inline void Flower::set_allocated_material_data(::MaterialsData* material_data) {
  delete material_data_;
  material_data_ = material_data;
  if (material_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Flower.material_data)
}

// .FlagsDescriptor flags = 22;
inline bool Flower::has_flags() const {
  return this != internal_default_instance() && flags_ != NULL;
}
inline void Flower::clear_flags() {
  if (GetArenaNoVirtual() == NULL && flags_ != NULL) delete flags_;
  flags_ = NULL;
}
inline const ::FlagsDescriptor& Flower::flags() const {
  // @@protoc_insertion_point(field_get:Flower.flags)
  return flags_ != NULL ? *flags_
                         : *::FlagsDescriptor::internal_default_instance();
}
inline ::FlagsDescriptor* Flower::mutable_flags() {
  
  if (flags_ == NULL) {
    flags_ = new ::FlagsDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:Flower.flags)
  return flags_;
}
inline ::FlagsDescriptor* Flower::release_flags() {
  // @@protoc_insertion_point(field_release:Flower.flags)
  
  ::FlagsDescriptor* temp = flags_;
  flags_ = NULL;
  return temp;
}
inline void Flower::set_allocated_flags(::FlagsDescriptor* flags) {
  delete flags_;
  flags_ = flags;
  if (flags) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Flower.flags)
}

// .ProductPricing pricing = 23;
inline bool Flower::has_pricing() const {
  return this != internal_default_instance() && pricing_ != NULL;
}
inline void Flower::clear_pricing() {
  if (GetArenaNoVirtual() == NULL && pricing_ != NULL) delete pricing_;
  pricing_ = NULL;
}
inline const ::ProductPricing& Flower::pricing() const {
  // @@protoc_insertion_point(field_get:Flower.pricing)
  return pricing_ != NULL ? *pricing_
                         : *::ProductPricing::internal_default_instance();
}
inline ::ProductPricing* Flower::mutable_pricing() {
  
  if (pricing_ == NULL) {
    pricing_ = new ::ProductPricing;
  }
  // @@protoc_insertion_point(field_mutable:Flower.pricing)
  return pricing_;
}
inline ::ProductPricing* Flower::release_pricing() {
  // @@protoc_insertion_point(field_release:Flower.pricing)
  
  ::ProductPricing* temp = pricing_;
  pricing_ = NULL;
  return temp;
}
inline void Flower::set_allocated_pricing(::ProductPricing* pricing) {
  delete pricing_;
  pricing_ = pricing;
  if (pricing) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Flower.pricing)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_products_2fFlower_2eproto__INCLUDED
